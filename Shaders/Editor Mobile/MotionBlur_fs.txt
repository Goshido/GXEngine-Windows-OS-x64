#version 330 core


#define CYLINDER_FUNCTION_ALPHA_FACTOR		0.95
#define CYLINDER_FUNCTION_BETTA_FACTOR		1.05
#define BLUR_MINIMUM_VELOCITY				0.5
#define COLOR_SLOT							0


smooth in vec2 v_uv;

uniform sampler2D velocityNeighborMaxSampler;
uniform sampler2D velocitySampler;
uniform sampler2D depthSampler;
uniform sampler2D imageSampler;

uniform float inverseDepthLimit;
uniform int maxBlurSamples;
uniform vec2 inverseScreenResolution;
uniform mat4 inverseProjectionMatrix;

layout ( location = COLOR_SLOT ) out vec3 outColor;


float GetDepthView ( const in vec2 uv )
{
	vec4 locationCVV;
	locationCVV.xy = gl_FragCoord.xy * inverseScreenResolution * 2.0 - 1.0;
	locationCVV.z = texture ( depthSampler, uv ).r * 2.0 - 1.0;
	locationCVV.w = 1.0;

	vec4 homogeneousLocationView = inverseProjectionMatrix * locationCVV;
	return homogeneousLocationView.z / homogeneousLocationView.w;
}

float GetDepthCompareFactor ( const in float a, const in float b )
{
	return clamp ( 1.0 - ( a - b ) * inverseDepthLimit, 0.0, 1.0 );
}

float ConeFunction ( const in vec2 a, const in vec2 b, const in vec2 c )
{
	float alpha = length ( a - b );
	float betta = 1.0 / length ( c );

	return clamp ( 1.0 - alpha * betta, 0.0, 1.0 );
}

float CylinderFunction ( const in vec2 a, const in vec2 b, const in vec2 c )
{
	float lengthC = length ( c );
	return 1.0 - smoothstep ( CYLINDER_FUNCTION_ALPHA_FACTOR * lengthC, CYLINDER_FUNCTION_BETTA_FACTOR * lengthC, length ( a - b ) );
}

void main ()
{
	float maxBlurSamplesFloat = float ( maxBlurSamples );
	vec2 velocityNeighborMaxSample = maxBlurSamplesFloat * ( texture ( velocityNeighborMaxSampler, v_uv ).xy * 2.0 - 1.0 );

	if ( length ( velocityNeighborMaxSample ) <= BLUR_MINIMUM_VELOCITY )
	{
		outColor = texture ( imageSampler, v_uv ).rgb;
		return;
	}

	vec2 velocityBlurSample = maxBlurSamplesFloat * ( texture ( velocitySampler, v_uv ).xy * 2.0 - 1.0 );

	float weight = 1.0 / length ( velocityBlurSample );
	vec3 sum = texture ( imageSampler, v_uv ).rgb * weight;

	float noiseFactor = 0.5 * noise1 ( v_uv.x + v_uv.y ) + 1.0;
	float alpha = 1.0 / ( maxBlurSamplesFloat + 1.0 );
	int ignore = ( maxBlurSamples - 1 ) / 2;
	float depthAView = GetDepthView ( v_uv );
	float iFloat = -1.0;
	int s = int ( ( length ( velocityBlurSample ) - 1.0 ) );

	for ( int i = 0; i < s; i++ )
	{
		iFloat += 1.0;

		if ( i == ignore ) continue;

		float lineCoordinate = mix ( -1.0, 1.0, ( iFloat + noiseFactor ) * alpha );
		vec2 checkUV = v_uv + velocityNeighborMaxSample * lineCoordinate * inverseScreenResolution;

		float depthBView = GetDepthView ( checkUV );
		vec2 checkBlur = maxBlurSamplesFloat * ( texture ( velocitySampler, checkUV ).xy * 2.0 - 1.0 ) * inverseScreenResolution;

		float mu = GetDepthCompareFactor ( depthAView, depthBView ) * ConeFunction ( checkUV, v_uv, checkBlur );
		mu += GetDepthCompareFactor ( depthBView, depthAView ) * ConeFunction ( v_uv, checkUV, velocityBlurSample * inverseScreenResolution );
		mu += CylinderFunction ( checkUV, v_uv, checkBlur ) * CylinderFunction ( v_uv, checkUV, velocityBlurSample * inverseScreenResolution ) * 2.0;

		weight += mu;
		sum += mu * texture ( imageSampler, checkUV ).rgb;
	}

	outColor = sum / weight;
}
