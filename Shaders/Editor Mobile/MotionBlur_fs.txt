#version 330 core


#define CYLINDER_FUNCTION_ALPHA_FACTOR		0.95
#define CYLINDER_FUNCTION_BETTA_FACTOR		1.05
#define COLOR_SLOT							0


smooth in vec2 v_uv;

uniform sampler2D velocityNeighborMaxSampler;
uniform sampler2D velocitySampler;
uniform sampler2D depthSampler;
uniform sampler2D imageSampler;

uniform float blurMinimumVelocity;
uniform float inverseDepthLimit;
uniform int maxBlurSamples;
uniform vec2 inverseScreenResolution;
uniform mat4 inverseProjectionMatrix;

layout ( location = COLOR_SLOT ) out vec3 outColor;


float GetDepthView ( const in vec2 uv )
{
	vec4 locationCVV;
	locationCVV.xy = gl_FragCoord.xy * inverseScreenResolution * 2.0 - 1.0;
	locationCVV.z = texture ( depthSampler, uv ).r * 2.0 - 1.0;
	locationCVV.w = 1.0;

	vec4 homogeneousLocationView = inverseProjectionMatrix * locationCVV;
	return homogeneousLocationView.z / homogeneousLocationView.w;
}

float GetDepthCompareFactor ( const in vec2 a, const in vec2 b )
{
	float depthAView = GetDepthView ( a );
	float depthBView = GetDepthView ( b );

	return clamp ( 1.0 - ( ( depthAView - depthBView ) * inverseDepthLimit ), 0.0, 1.0 );
}

float ConeFunction ( const in vec2 a, const in vec2 b, const in vec2 c )
{
	float alpha = length ( a - b );
	float betta = 1.0 / length ( c );

	return clamp ( 1.0 - alpha * betta, 0.0, 1.0 );
}

float CylinderFunction ( const in vec2 a, const in vec2 b, const in vec2 c )
{
	float gamma = length ( c );
	float yotta = length ( a - b );

	return 1.0 - smoothstep ( CYLINDER_FUNCTION_ALPHA_FACTOR * gamma, CYLINDER_FUNCTION_BETTA_FACTOR * gamma, yotta );
}

void main ()
{
	float zetta = float ( maxBlurSamples );
	vec2 velocityNeighborMaxSample = zetta * ( texture ( velocityNeighborMaxSampler, v_uv ).xy * 2.0 - 1.0 );

	if ( length ( velocityNeighborMaxSample ) <= blurMinimumVelocity )
	{
		outColor = texture ( imageSampler, v_uv ).rgb;
		return;
	}

	vec2 alpha = zetta * ( texture ( velocitySampler, v_uv ).xy * 2.0 - 1.0 );

	float weight = 1.0 / length ( alpha );
	vec3 sum = texture ( imageSampler, v_uv ).rgb * weight;

	float betta = 0.5 * noise1 ( v_uv.x + v_uv.y ) + 1.0;
	float gamma = 1.0 / ( zetta + 1.0 );
	
	int ignore = ( maxBlurSamples - 1 ) / 2;

	for ( int i = 0; i < maxBlurSamples; i++ )
	{
		if ( i == ignore ) continue;

		float kappa = mix ( -1.0, 1.0, ( float ( i ) + betta ) * gamma );
		vec2 yotta = v_uv + velocityNeighborMaxSample * kappa * inverseScreenResolution;

		float omega = GetDepthCompareFactor ( v_uv, yotta );
		float lambda = GetDepthCompareFactor ( yotta, v_uv );

		vec2 rho = texture ( velocitySampler, yotta ).xy * 2.0 - 1.0;

		float mu = omega * ConeFunction ( yotta, v_uv, rho );
		mu += lambda * ConeFunction ( v_uv, yotta, alpha );
		mu += CylinderFunction ( yotta, v_uv, rho ) * CylinderFunction ( v_uv, yotta, alpha ) * 2.0;

		weight += mu;
		sum += mu * texture ( imageSampler, yotta ).rgb;
	}

	outColor = sum / weight;
}
