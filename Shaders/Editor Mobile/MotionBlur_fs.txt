#version 330 core


#define TOTAL_SAMPLES		8
#define COLOR_SLOT			0


smooth in vec2 v_uv;

uniform sampler2D velocitySampler;
uniform sampler2D depthSampler;
uniform sampler2D imageSampler;

uniform float blurStrength;
uniform float blurMinimumVelocity;
uniform float blurDepthFactorView;
uniform vec2 inverseScreenResolution;
uniform mat4 inverseProjectionMatrix;

layout ( location = COLOR_SLOT ) out vec3 outColor;


float GetDepthView ( in vec2 uv )
{
	vec4 locationCVV;
	locationCVV.xy = gl_FragCoord.xy * inverseScreenResolution * 2.0 - 1.0;
	locationCVV.z = texture ( depthSampler, uv ).r * 2.0 - 1.0;
	locationCVV.w = 1.0;

	vec4 homogeneousLocationView = inverseProjectionMatrix * locationCVV;
	return homogeneousLocationView.z / homogeneousLocationView.w;
}

void main ()
{
	vec3 velocityView = texture ( velocitySampler, v_uv ).xyz;
	float depthView = GetDepthView ( v_uv );
	float perspectiveCorrectedVelocityMagnitude = length ( velocityView.xy ) / depthView;

	if ( perspectiveCorrectedVelocityMagnitude < blurMinimumVelocity ) 
	{
		outColor = texture ( imageSampler, v_uv ).xyz;
		return;
	}

	vec2 lookupStep = -blurStrength * ( velocityView.xy / depthView );
	vec2 lookupUV = v_uv;

	float hits = 1.0;
	vec3 colorSum = texture ( imageSampler, lookupUV ).rgb;
	lookupUV += lookupStep;

	for ( int i = 1; i < TOTAL_SAMPLES; i++ )
	{
		float sampleDepthView = GetDepthView ( lookupUV );
		if ( abs ( sampleDepthView - depthView ) < blurDepthFactorView )
		{
			hits += 1.0;
			colorSum += texture ( imageSampler, lookupUV ).rgb;
		}

		lookupUV += lookupStep;
	}

	float invHits = 1.0 / hits;
	outColor = colorSum * invHits;
}
