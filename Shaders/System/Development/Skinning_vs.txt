#version 330 core


#define VERTEX_STREAM			0
#define UV_STREAM				1
#define NORMAL_STREAM			2
#define TANGENT_STREAM			3
#define BITANGENT_STREAM		4
#define WEIGHT_INDICES_STREAM	5
#define WEIGHTS_STREAM			6

#define MAX_BONES				80
#define FLOATS_PER_BONE			7


layout ( location = VERTEX_STREAM ) in vec3 vertex;
layout ( location = UV_STREAM ) in vec2 uv;
layout ( location = NORMAL_STREAM ) in vec3 normal;
layout ( location = TANGENT_STREAM ) in vec3 tangent;
layout ( location = BITANGENT_STREAM ) in vec3 bitangent;
layout ( location = WEIGHT_INDICES_STREAM ) in vec4 weightIndices;
layout ( location = WEIGHTS_STREAM ) in vec4 weights;

uniform float bones[ MAX_BONES * FLOATS_PER_BONE ];

flat out vec3 v_vertex;
flat out vec2 v_uv;
flat out vec3 v_normal;
flat out vec3 v_tangent;
flat out vec3 v_bitangent;


vec3 VertexSkinning ( const in vec3 p, const in int index )
{
	int i = index * FLOATS_PER_BONE;

	float r = bones[ i ];
	float a = bones[ i + 1 ];
	float b = bones[ i + 2 ];
	float c = bones[ i + 3 ];

	float rr = r * r;
	float ra2 = r * a * 2.0f;
	float rb2 = r * b * 2.0f;
	float rc2 = r * c * 2.0f;

	float aa = a * a;
	float ab2 = a * b * 2.0f;
	float ac2 = a * c * 2.0f;

	float bb = b * b;
	float bc2 = b * c * 2.0f;

	float cc = c * c;

	mat3 transform;

	//GLSL is column-major matrix notation. See GLSL 3.30 specification (49 page).

	transform[ 0 ][ 0 ] = rr + aa - bb - cc;
	transform[ 1 ][ 0 ] = rc2 + ab2;
	transform[ 2 ][ 0 ] = ac2 - rb2;

	transform[ 0 ][ 1 ] = ab2 - rc2;
	transform[ 1 ][ 1 ] = rr - aa + bb - cc;
	transform[ 2 ][ 1 ] = ra2 + bc2;

	transform[ 0 ][ 2 ] = rb2 + ac2;
	transform[ 1 ][ 2 ] = bc2 - ra2;
	transform[ 2 ][ 2 ] = rr - aa - bb + cc;

	return p * transform + vec3 ( bones[ i + 4 ], bones[ i + 5 ], bones[ i + 6 ] );
}

vec3 VectorSkinning ( const in vec3 v, const in int index )
{
	int i = index * FLOATS_PER_BONE;

	float r = bones[ i ];
	float a = bones[ i + 1 ];
	float b = bones[ i + 2 ];
	float c = bones[ i + 3 ];

	float rr = r * r;
	float ra2 = r * a * 2.0f;
	float rb2 = r * b * 2.0f;
	float rc2 = r * c * 2.0f;

	float aa = a * a;
	float ab2 = a * b * 2.0f;
	float ac2 = a * c * 2.0f;

	float bb = b * b;
	float bc2 = b * c * 2.0f;

	float cc = c * c;

	mat3 transform;

	//GLSL is column-major matrix notation. See GLSL 3.30 specification (49 page).

	transform[ 0 ][ 0 ] = rr + aa - bb - cc;
	transform[ 1 ][ 0 ] = rc2 + ab2;
	transform[ 2 ][ 0 ] = ac2 - rb2;

	transform[ 0 ][ 1 ] = ab2 - rc2;
	transform[ 1 ][ 1 ] = rr - aa + bb - cc;
	transform[ 2 ][ 1 ] = ra2 + bc2;

	transform[ 0 ][ 2 ] = rb2 + ac2;
	transform[ 1 ][ 2 ] = bc2 - ra2;
	transform[ 2 ][ 2 ] = rr - aa - bb + cc;

	return v * transform;
}

void main ()
{
	vec3 v = VertexSkinning ( vertex, int ( weightIndices.x ) ) * weights.x;
	v += VertexSkinning ( vertex, int ( weightIndices.y ) ) * weights.y;
	v += VertexSkinning ( vertex, int ( weightIndices.z ) ) * weights.z;
	v += VertexSkinning ( vertex, int ( weightIndices.w ) ) * weights.w;

	v_vertex = v;

	v_uv = uv;

	v = VectorSkinning ( normal, int ( weightIndices.x ) ) * weights.x;
	v += VectorSkinning ( normal, int ( weightIndices.y ) ) * weights.y;
	v += VectorSkinning ( normal, int ( weightIndices.z ) ) * weights.z;
	v += VectorSkinning ( normal, int ( weightIndices.w ) ) * weights.w;

	v_normal = v;

	v = VectorSkinning ( tangent, int ( weightIndices.x ) ) * weights.x;
	v += VectorSkinning ( tangent, int ( weightIndices.y ) ) * weights.y;
	v += VectorSkinning ( tangent, int ( weightIndices.z ) ) * weights.z;
	v += VectorSkinning ( tangent, int ( weightIndices.w ) ) * weights.w;

	v_tangent = v;

	v = VectorSkinning ( bitangent, int ( weightIndices.x ) ) * weights.x;
	v += VectorSkinning ( bitangent, int ( weightIndices.y ) ) * weights.y;
	v += VectorSkinning ( bitangent, int ( weightIndices.z ) ) * weights.z;
	v += VectorSkinning ( bitangent, int ( weightIndices.w ) ) * weights.w;

	v_bitangent = v;
}
